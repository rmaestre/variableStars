# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Main process function
#'
#' The complete workflow can be found in the readme section.
#'
#' @param frequency Vector with frequences
#' @param amplitude Vector with amplitudes
#' @param filter Apodization filter
#' @param gRegimen Value to drop frecuencies in the G regimen
#' @param numFrequencies Number of frecuences to be processes calculated
#' for a range
#' @param maxDnu Maximum Dnu allowed
#' @param minDnu Minimum Dnu allowed
#' @param dnuGuessError Dnu error guessing
#' @param dnuValue Epecific Dnu value
#' @param dnuEstimation Flag to estimate ot not the Dnu vale
#' @param debug Flag to activate verbose debuggin information
#' @return A vector with histogram of differences and other middle-results
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' 
#' paramters = list(
#'   "filter" = "gaussian",
#'   "gRegimen" = 0,
#'   "minDnu" = 15,
#'   "maxDnu" = 95,
#'   "dnuValue" = -1,
#'   "dnuGuessError" = 10,
#'   "dnuEstimation" = TRUE,
#'   "numFrequencies" = 30,
#'   "debug" = TRUE)
#' 
#' result <- process(
#'     dt.spectrum$frequency,
#'     dt.spectrum$amplitude,
#'     filter = paramters$filter,
#'     gRegimen = paramters$gRegimen,
#'     minDnu = paramters$minDnu,
#'     maxDnu = paramters$maxDnu,
#'     dnuValue = paramters$dnuValue,
#'     dnuGuessError = paramters$dnuGuessError,
#'     dnuEstimation = paramters$dnuEstimation,
#'     numFrequencies = paramters$numFrequencies,
NULL

#' Create a vector as sequence of integers
#'
#' This function helps to create a vector with a secuence
#' of integers equally separated
#'
#' @param first The first element of the sequence
#' @param last The last element of the sequence
#' @return A numeric vector with the whole secuence of integers
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' seqIntegers(1,10)
#' # simple call with negative numbers
#' seqIntegers(-10,10)
#' }
#' @export
seqIntegers <- function(first, last) {
    .Call(`_variableStars_seqIntegers`, first, last)
}

#' Revert the order of an input vector
#'
#' Revert the order of the elements an input vector
#'
#' @param vector Numerix vector to be reversed
#' @return A numeric vector with elements in reverse mode
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' vectorRev(c(1,2,3,4,5,6))
#' # simple call with negative nummbers
#' vectorRev(c(1,-2,3,-4,5,-6))
#' }
#' @export
vectorRev <- function(vector) {
    .Call(`_variableStars_vectorRev`, vector)
}

#' Fast Fourier Transform
#'
#' Compute the discrete fourier transform using the 
#' the fast FT algorithm provided by the Armadillo library
#'
#' @param v Armadillo vector with numeric elements
#' @return A complex vector with the FT result
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' computeFft(sin(seq(1:100)))
#' }
#' @export
computeFft <- function(v) {
    .Call(`_variableStars_computeFft`, v)
}

#' Calculate the spectrum from a given vector
#'
#' Calculate frequency, amplitude and phase from a given vector
#' using the Fast Fourier Tramsform algorithm.
#'
#' @param time Armadillo vector representing the meassurements time
#' @param x Armadillo vector with numeric elements
#' @return A complex vector with the calculated spectrum
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' sample <- sin(seq(1:100))
#' calculateSpectrum(seq(1:length(sample)),sample)
#' }
#' @export
calculateSpectrum <- function(time, x) {
    .Call(`_variableStars_calculateSpectrum`, time, x)
}

#' Apodization
#'
#' Apodization, tapering or window function is a function 
#' used to smoothly bring a sampled signal down to zero at the edges 
#' of the sampled region
#'
#' @param frequences Armadillo vector with frequences
#' @param filter A string with a specific filter (bartlett, blackman,
#' connes, cosine, gaussian, hamming, hanning, welch or uniform by-default)
#' @return The apoditazed frequence vector
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' apodization(c(1,2,3,4), "gaussian")
#' apodization(c(1,2,3,4), "blackman")
#' 
#' }
#' @export
apodization <- function(frequences, filter) {
    .Call(`_variableStars_apodization`, frequences, filter)
}

#' Triangular Superior absolute differences of a vector
#'
#' Given a vector, this function calculates the triangular
#' superior differences combination. All differences are
#' absolute and zero-difference will be drop
#'
#' @param frequences Armadillo vector with frequences
#' @return The vector with all differences
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' differences(c(1,2,3,4,5))
#' # simple call returning an empty vector because all 
#' # differences are equal to 0:
#' differences(rep(1,10))
#' 
#' }
#' @export
differences <- function(frequences) {
    .Call(`_variableStars_differences`, frequences)
}

#' Histogram of differences
#'
#' Given a vector, this function calculates the histogram
#' of the non-zero and absolute differences of a given vector
#' taking into account a Dnu
#'
#' @param frequences Armadillo vector with frequences
#' @param dnu Numeric value for the spectral resolution
#' @return A list with bins and values representing an histogram
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' differences(c(1,2,3,4,5))
#' # simple call returning an empty vector because all 
#' # differences are equal to 0:
#' differences(rep(1,10))
#' 
#' }
#' @export
diffHistogram <- function(frequences, dnu) {
    .Call(`_variableStars_diffHistogram`, frequences, dnu)
}

#' Apodization and FT
#'
#' Apodization of a given vector with one filter and
#' Fourier Transform calculation
#'
#' @param frequences Armadillo vector with frequences
#' @param filter A string with a specific filter (bartlett, blackman,
#' connes, cosine, gaussian, hamming, hanning, welch or uniform by-default)
#' @return A list with amplitudes, frequences, inverse frecuences and the
#' power spectrum calculated.
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' r <- ft(sin(seq(1:100)), "uniform")
#' plot(r$f, r$powerSpectrum)
#' }
#' @export
apodizationFt <- function(frequences, filter) {
    .Call(`_variableStars_apodizationFt`, frequences, filter)
}

#' Calculate adjacent differences in a vector
#'
#' All differences between adjacent elements in a vector
#'
#' @param x Armadillo vector with numeric element
#' @return Armadillo vector with the adjacent differences
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call: All adjacent elements has the same length 1
#' adjacentDifferences(c(1,2,3,4,5))
#' # simple call: There are positive and negative diffferences
#' adjacentDifferences(c(1,2,0,14,-2))
#' }
#' @export
adjacentDifferences <- function(x) {
    .Call(`_variableStars_adjacentDifferences`, x)
}

#' Find highest peaks in a time series
#'
#' Inspired in the quantmod::findPeaks() R algorithm, 
#' this function find the highest peaks in a time series.
#'
#' @param x Armadillo vector with numeric element
#' @return Armadillo unsigned vector with the index representing 
#' the position of the selected peaks
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call: Returns position 1,4 and 7 with the highest peaks
#' findPeaks(c(1,2,1,2,10,1,2,3,1))
#' }
#' @export
findPeaks <- function(x) {
    .Call(`_variableStars_findPeaks`, x)
}

#' Split elements in ranges
#'
#' Inspired in the quantmod::findPeaks() R algorithm, 
#' this function find the highest peaks in a time series.
#'
#' @param nElements Number of elements to be splitted
#' @param numFrequencies Number of total frequences
#' @return A vector of ranges in integer format
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' calculateRange(100,100)
#' calculateRange(100,100)
#' calculateRange(10,200)
#' calculateRange(1,20)
#' }
#' @export
calculateRange <- function(nElements, nFrequencies) {
    .Call(`_variableStars_calculateRange`, nElements, nFrequencies)
}

#' Crosscorrelation
#'
#' This function calculates the crosscorrelation of the
#' frequency vector by using a sum of gaussians
#'
#' @param frequencies The frequences to be processed
#' @param lagMax Maximum lag at which to calculate the acf
#' (null by default)
#' @param type character string giving the type of acf to be 
#' computed. Allowed values are "correlation" or 
#' "covariance" (correlation by default).
#' @param plot If true the acf is plotted (true by default)
#' @return A vector with the crosscorrelations
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' crosscorrelation(sin(c(1,2,3,4,5,4,3,2,1)), lagMax = 50, plot=T)
#' }
#' @export
crosscorrelation <- function(frequencies, type = "correlation", plot = FALSE) {
    .Call(`_variableStars_crosscorrelation`, frequencies, type, plot)
}

#' Echelle diagram
#'
#' Diagram to plot Echelle: the mode frequencies plotted 
#' as a function of the frequency modulo the large separation
#'
#' @param frequency Vector with frequences
#' @param amplitudes Vector with amplitudes
#' @param dnu Selected dnu
#' @return A list with x-y axis to plott a Echelle diagram plus 
#' the amplitude in each frequency
#' @author Roberto Maestre
#' @examples
#' \dontrun{
#' # simple call:
#' echelle(c(1,2,3,1,2,3,1,2,3), c(1,1,1,1,2,2,2,2), 2)
#' }
#' @export
echelle <- function(frequencies, amplitudes, dnu) {
    .Call(`_variableStars_echelle`, frequencies, amplitudes, dnu)
}

#' }
#' @export
process <- function(frequency, amplitude, filter, gRegimen, numFrequencies, maxDnu, minDnu, dnuGuessError, dnuValue = -1, dnuEstimation = FALSE, debug = FALSE, processFirstRangeOnly = FALSE) {
    .Call(`_variableStars_process`, frequency, amplitude, filter, gRegimen, numFrequencies, maxDnu, minDnu, dnuGuessError, dnuValue, dnuEstimation, debug, processFirstRangeOnly)
}

